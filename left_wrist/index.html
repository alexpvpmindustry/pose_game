<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hand-Controlled Bird Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/addons/p5.sound.min.js"></script>
  <script src="https://unpkg.com/ml5@1/dist/ml5.min.js"></script>
  <style>
    body { 
      margin: 0; 
      padding: 0; 
      overflow: hidden; 
      background: #87ceeb; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      height: 100vh;
      font-family: Arial, sans-serif;
    }
    canvas { display: block; }
    .instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 100;
    }
    .camera-status {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="instructions">
    <div>Hold up your hand and move it left/right to control the bird!</div>
    <div>Allow camera access to start playing</div>
  </div>
  <div class="camera-status" id="cameraStatus">Initializing camera...</div>

<script>
// Game variables
let bird, pipes = [];
let pipeGap = 150;
let pipeMin = 50;
let score = 0, lastScore = 0, scoreFlashTimer = 0, gameOver = false;
let kaChing;
let prevtime = Date.now();
let currenttime = Date.now();
let fps = 60;
let fixedWidth = 800;
let fixedHeight = 600;

// Hand pose detection variables
let video;
let handPose;
let hands = [];
let handX = 0;
let cameraReady = false;
let handDetected = false;

// Control smoothing
let smoothedHandX = 0;
let smoothingFactor = 0.25;

function preload() {
  soundFormats('mp3', 'wav', 'ogg');
  kaChing = loadSound('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg');
  
  // Initialize HandPose model
  handPose = ml5.handPose({
    flipped: true,
    maxHands: 2
  });
}

function setup() {
  createCanvas(fixedWidth, fixedHeight);
  
  // Setup video capture
  video = createCapture(VIDEO, { flipped: true });
  video.size(160, 120); // Small video for performance
  video.hide();
  
  // Setup hand pose detection
  handPose.detectStart(video, gotHands);
  
  // Initialize game
  resetGame();
  
  // Update camera status
  setTimeout(() => {
    cameraReady = true;
    document.getElementById('cameraStatus').textContent = 'Camera ready - Show your hand!';
  }, 2000);
}

function gotHands(results) {
  hands = results;
  if (hands.length > 0) {
    handDetected = true;
    let hand = hands[0]; // Use the first detected hand
    
    if (hand.keypoints && hand.keypoints.length > 0) {
      // Use the wrist keypoint (index 0) for hand position
      let wrist = hand.keypoints[0];
      
      // Map hand position from video coordinates to game coordinates
      handX = map(wrist.x, 0, video.width, 0, width);
      
      // Smooth the movement
      smoothedHandX = lerp(smoothedHandX, handX, smoothingFactor);
      
      document.getElementById('cameraStatus').textContent = `Hand detected (${hand.handedness}) - Hand control active!`;
    }
  } else {
    handDetected = false;
    document.getElementById('cameraStatus').textContent = 'No hand detected - Hold up your hand!';
  }
}

function resetGame() {
  bird = new Bird();
  pipes = [];
  score = 0;
  lastScore = 0;
  prevtime = Date.now();
  scoreFlashTimer = 0;
  frameCount = 0;
  gameOver = false;
  smoothedHandX = width / 2;
  loop();
}

function draw() {
  background('#87ce00');
  
  // Draw small video preview in corner
  if (video && cameraReady) {
    push();
    tint(255, 100); // Make it semi-transparent
    image(video, width - 160 - 10, height - 120 - 10, 160, 120);
    
    // Draw hand keypoints on video preview
    if (hands.length > 0) {
      let hand = hands[0];
      if (hand.keypoints && hand.keypoints.length > 0) {
        // Draw all hand keypoints
        for (let keypoint of hand.keypoints) {
          let previewX = map(keypoint.x, 0, video.width, width - 160 - 10, width - 10);
          let previewY = map(keypoint.y, 0, video.height, height - 120 - 10, height - 10);
          
          fill(255, 100, 100);
          noStroke();
          circle(previewX, previewY, 4);
        }
        
        // Highlight the wrist (main control point)
        let wrist = hand.keypoints[0];
        let previewWristX = map(wrist.x, 0, video.width, width - 160 - 10, width - 10);
        let previewWristY = map(wrist.y, 0, video.height, height - 120 - 10, height - 10);
        fill(255, 0, 0);
        stroke(255);
        strokeWeight(2);
        circle(previewWristX, previewWristY, 12);
        
        // Draw hand connections
        noFill();
        stroke(100, 255, 100);
        strokeWeight(1);
        
        // Define hand connections (simplified)
        let connections = [
          [0, 1], [1, 2], [2, 3], [3, 4], // thumb
          [0, 5], [5, 6], [6, 7], [7, 8], // index
          [0, 9], [9, 10], [10, 11], [11, 12], // middle
          [0, 13], [13, 14], [14, 15], [15, 16], // ring
          [0, 17], [17, 18], [18, 19], [19, 20] // pinky
        ];
        
        for (let connection of connections) {
          let from = hand.keypoints[connection[0]];
          let to = hand.keypoints[connection[1]];
          if (from && to) {
            let fromX = map(from.x, 0, video.width, width - 160 - 10, width - 10);
            let fromY = map(from.y, 0, video.height, height - 120 - 10, height - 10);
            let toX = map(to.x, 0, video.width, width - 160 - 10, width - 10);
            let toY = map(to.y, 0, video.height, height - 120 - 10, height - 10);
            line(fromX, fromY, toX, toY);
          }
        }
      }
    }
    pop();
  }

  // Update bird position based on hand position
  if (handDetected && hands.length > 0) {
    bird.setTargetX(smoothedHandX);
  }

  // Game logic
  for (let i = pipes.length - 1; i >= 0; i--) {
    pipes[i].update();
    pipes[i].show();

    if (pipes[i].hits(bird)) {
      noLoop();
      if (!gameOver) {
        gameOver = true;
        setTimeout(() => {
          if (confirm("Game Over! Your score was: " + score + "\nPlay again?")) {
            resetGame();
          }
        }, 100);
      }
    }

    if (pipes[i].offscreen()) {
      score++;
      pipes.splice(i, 1);
    }
  }

  if (score > lastScore) {
    scoreFlashTimer = 15;
    lastScore = score;
    if (kaChing && kaChing.isLoaded()) {
      kaChing.setVolume(0.13);
      kaChing.play();
    }
  }

  bird.update();
  bird.show();

  if (frameCount % 130 == 0) {
    pipes.push(new Pipe());
  }

  // UI
  push();
  fill(255);
  noStroke();
  textSize(16);
  text("Frame: " + frameCount, 10, height - 80);
  if (frameCount % 50 == 0) {
    currenttime = Date.now();
    fps = Math.floor(50 / (currenttime - prevtime) * 1000);
    prevtime = currenttime;
  }
  text("FPS: " + fps, 10, height - 60);
  
  // Show hand detection status
  if (handDetected) {
    fill(0, 255, 0);
    text("Hand: DETECTED", 10, height - 40);
    if (hands.length > 0) {
      text("Handedness: " + hands[0].handedness, 10, height - 20);
    }
  } else {
    fill(255, 0, 0);
    text("Hand: NOT DETECTED", 10, height - 40);
    text("Hold up your hand!", 10, height - 20);
  }

  textSize(32);
  fill(255);
  text("Score: ", 10, 40);
  if (scoreFlashTimer > 0) {
    fill(255, 255, 0);
    textSize(32 + scoreFlashTimer);
    scoreFlashTimer--;
  } else {
    fill(255);
    textSize(32);
  }
  text(score, 130, 40);
  pop();
}

// Fallback keyboard controls
function keyPressed() {
  if (key === 'r' || key === 'R') {
    resetGame();
  }
}

class Bird {
  constructor() {
    this.x = width / 2;
    this.y = height - 30;
    this.targetX = width / 2;
    this.size = 32;
    this.speed = 8;
  }

  setTargetX(tx) {
    this.targetX = constrain(tx, this.size / 2, width - this.size / 2);
  }

  update() {
    // Smooth movement towards target position
    this.x = lerp(this.x, this.targetX, 0.2);
  }

  show() {
    fill(255, 50, 50);
    stroke(255);
    strokeWeight(2);
    ellipse(this.x, this.y, this.size, this.size);
    
    // Draw eyes
    fill(255);
    noStroke();
    ellipse(this.x - 6, this.y - 4, 8, 8);
    ellipse(this.x + 6, this.y - 4, 8, 8);
    fill(0);
    ellipse(this.x - 6, this.y - 4, 4, 4);
    ellipse(this.x + 6, this.y - 4, 4, 4);
  }
}

class Pipe {
  constructor() {
    this.w = random(pipeMin, width - pipeGap - pipeMin);
    this.gap = pipeGap;
    this.y = 0;
    this.h = 40;
    this.speed = 2;
  }

  hits(bird) {
    const topY = this.y;
    const botY = this.y + this.h;
    const left1 = 0;
    const right1 = this.w;
    const left2 = this.w + this.gap;
    const right2 = width;

    const bx = bird.x;
    const by = bird.y;
    const r = bird.size / 2;

    const hitLeft = bx + r > left1 && bx - r < right1 && by + r > topY && by - r < botY;
    const hitRight = bx + r > left2 && bx - r < right2 && by + r > topY && by - r < botY;

    return hitLeft || hitRight;
  }

  offscreen() {
    return this.y > height;
  }

  update() {
    this.y += this.speed;
  }

  show() {
    fill(34, 139, 34);
    stroke(0, 100, 0);
    strokeWeight(2);
    rect(0, this.y, this.w, this.h);
    rect(this.w + this.gap, this.y, width - this.w - this.gap, this.h);
  }
}
</script>
</body>
</html>